created: 20241122015034347
creator: uzvg
modified: 20250317081611200
modifier: uzvg
tags: FleetingNotes
title: 什么是正则表达式中的零宽断言？
type: text/vnd.tiddlywiki

https://chatgpt.com/share/673fe5b8-0620-800f-87e7-156dd3c6e8c6

4. 零宽断言的独特语义
正则表达式中的“零宽断言”，在语义层面可以理解为：

“零宽”：强调断言的位置是“无实际宽度”的，即它并不占用字符串中的任何字符。
“断言”：表示它的作用是一个“位置判断条件”，不是字符匹配条件。
例如，(?=Y) 的语义是：

当前匹配位置后面是否存在 Y，如果是，则允许继续匹配下一个部分。
而 (?!Y) 的语义是：

当前匹配位置后面是否不存在 Y，如果是，则允许继续匹配下一个部分。
换句话说，零宽断言相当于说：

“在某个条件下，我允许这个位置的匹配成功。”

它是对“位置”的条件判断，而不是对“字符”的捕获或消耗。

总结语义理解
**“断言”**的本质是“声明”和“条件验证”，在正则中，它的语义就是对当前位置是否满足某种条件进行判断：

位置的验证者：判断某个位置是否符合条件；
逻辑的过滤器：允许匹配通过或否决，而不改变匹配的范围；
行为的约束器：对匹配动作增加额外的逻辑约束。
这种语义上的“断言”强调了其“判断”而非“动作”的特性，帮助我们理解其在正则表达式中的作用和本质。


正则表达式中的“零宽断言”（lookahead 和 lookbehind）是非常有用的概念，但也容易混淆。它们不消耗字符，只用于判断一个位置是否满足特定条件。零宽断言分为四种类型，具体包括：

### 1. 正向先行断言（Positive Lookahead）
- 语法：`X(?=Y)`
- 含义：表示“当前位置后面紧跟着Y”，但不包括Y本身。
- 解释：`X` 后面必须紧跟着 `Y`，但正则表达式匹配到的是 `X`，而 `Y` 并不会被包含在匹配结果中。

**示例：**
```regex
\d(?=\D)
```
- 这个正则表示匹配一个数字字符 `\d`，且该数字后面必须紧跟一个非数字字符 `\D`，但正则本身只匹配数字字符。

### 2. 负向先行断言（Negative Lookahead）
- 语法：`X(?!Y)`
- 含义：表示“当前位置后面不紧跟着Y”，也就是说 `X` 后面不能是 `Y`。
- 解释：`X` 后面不能跟着 `Y`，但正则表达式匹配到的是 `X`，而 `Y` 不会出现在匹配结果中。

**示例：**
```regex
\d(?!\d)
```
- 这个正则表示匹配一个数字字符 `\d`，且该数字后面不能再跟着另一个数字字符。也就是说，匹配的是“最后一个数字”。

### 3. 正向后行断言（Positive Lookbehind）
- 语法：`(?<=Y)X`
- 含义：表示“当前位置前面有Y”，即当前位置的前面必须是Y。
- 解释：正则表达式会匹配 `X`，前提是 `X` 的前面紧跟着 `Y`，但 `Y` 本身不会被包括在匹配结果中。

**示例：**
```regex
(?<=@)\w+
```
- 这个正则表示匹配一个以 `@` 为前缀的单词（例如，电子邮件地址中的用户名部分），但 `@` 本身不包括在匹配结果中。

### 4. 负向后行断言（Negative Lookbehind）
- 语法：`(?<!Y)X`
- 含义：表示“当前位置前面没有Y”，即当前位置前面不能是 `Y`。
- 解释：`X` 前面不能是 `Y`，但正则表达式匹配到的是 `X`，而 `Y` 不会出现在匹配结果中。

**示例：**
```regex
(?<!@)\w+
```
- 这个正则表示匹配一个不以 `@` 为前缀的单词。它会排除掉像电子邮件地址中包含 `@` 的部分。

### 小结：
- **正向先行断言** `(X(?=Y))`: 当前位置后面要跟着 `Y`。
- **负向先行断言** `(X(?!Y))`: 当前位置后面不能跟着 `Y`。
- **正向后行断言** `((?<=Y)X)`: 当前位置前面要是 `Y`。
- **负向后行断言** `((?<!Y)X)`: 当前位置前面不能是 `Y`。

零宽断言的作用是让你能够在正则表达式中“查看”某个位置是否满足条件，而不消耗字符，因此它们不包含在最终的匹配结果中。