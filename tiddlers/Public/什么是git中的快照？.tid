created: 20241222060649399
modified: 20250317090326808
modifier: uzvg
progress: Rethinking
rating: Doubtful
tags: Git PermanentNotes
title: 什么是git中的快照？
type: text/vnd.tiddlywiki
visibility: Public

“快照”是 Git 的核心概念之一，它是 Git 用来记录文件状态的一种方式，但它与传统的文件“拷贝”有本质区别。为了更好地理解，我们不仅需要明确“快照”的含义，还需要了解 Git 的工作原理。以下是详细的解释和形象的例子：

!!! ''1. 什么是快照？''

* ''传统的文件备份：'' 通常备份系统会将整个文件的完整拷贝保存下来，比如每天保存一份文件夹的副本。这种方法非常耗费空间。
* ''Git 的快照：'' Git 不会保存每次提交时文件的完整拷贝，而是保存整个项目的状态（快照）。但如果某个文件在新旧版本之间没有变化，Git 只保存对旧文件的引用，而不是重复存储文件内容。

换句话说，Git 的“快照”是一种''高效的文件状态记录''：

# 它会保存所有被修改过的文件的内容。
# 对于没有变化的文件，它只保存一个指向之前版本的引用。

---

!!! ''2. 形象的例子：画室档案''

想象你是一个艺术家，每次创作画作时，你都会记录下整个画室的状态。

!!!! ''过程：''

# 初始状态：你刚开始画画，画室里只有一块空白画布。你给画室拍了一张照片（Git 的“快照”）。
# 第一次修改：你在画布上画了一棵树。你又拍了一张照片，但这次只是记录了画布的新内容（树），其他没有变化的部分只是引用了之前的状态。
# 再次修改：你在画布上加了一片蓝天。新的照片记录了蓝天的内容，树的部分仍然引用了之前的快照。

!!!! ''快照的特点：''

* 每张照片代表一次提交，它记录了整个画室的“状态”。
* 不重复保存不变的部分，只保存修改的内容。

---

!!! ''3. Git 的工作原理''

Git 的工作原理可以总结为以下几点：

!!!! ''（1）对象存储''

Git 的核心是一个称为 “Git 对象数据库” 的地方，它存储三种主要对象：

* ''Blob（文件内容）：'' 保存文件的内容，但不记录文件名。
* ''Tree（目录结构）：'' 保存文件名和目录结构，并指向具体的 Blob 对象。
* ''Commit（提交对象）：'' 保存当前快照的元数据（比如作者、提交时间）和指向 Tree 的引用。

!!!! ''（2）指针和引用''

* 每次提交时，Git 会创建一个新的提交对象，指向当前的 Tree。
* 如果文件内容没有变化，Git 不会创建新的 Blob，而是重用现有的 Blob。

---

!!! ''4. 形象的例子：图书馆和书签''

Git 可以类比为一个图书馆，管理着各种书籍和书签：

!!!! ''书籍（Blob）''

* 图书馆里存放了每个文件的内容（Blob）。
* 如果两个版本的文件内容相同，图书馆不会重复保存，只会用一个书签指向原来的书籍。

!!!! ''书签（Tree 和 Commit）''

* 每次提交时，Git 会创建一本目录书（Tree），记录当前版本中每本书（文件）的存放位置。
* 提交（Commit）是对目录书的索引，包含提交时间、作者等信息，以及指向上一个提交的书签。

---

!!! ''5. 为什么快照不是拷贝？''

* 拷贝：每次保存时都完整复制所有文件，空间占用大，效率低。
* 快照：只保存改动的文件内容和对旧版本的引用，空间占用小，效率高。

Git 的快照方式让它能快速比较、回滚和合并文件，而不需要存储多份冗余数据。

---

!!! ''6. 总结：Git 的版本管理为什么高效？''

# ''数据存储分离：'' 文件内容（Blob）和目录结构（Tree）分离存储，避免重复记录。
# ''引用机制：'' 未修改的文件通过引用重用，节省空间。
# ''指针追踪：'' 提交（Commit）是指针的链条，可以快速追溯历史版本。

---

!!! ''图解说明''

如果需要更直观的理解，可以想象：

* ''Blob 是书的内容''
* ''Tree 是书架的目录''
* ''Commit 是馆长写的日志，记录每次书架调整的情况''

这种分离式管理，使 Git 能在极高效的情况下完成版本控制任务！
